using System;
using System.Collections.Generic;
using UnityEngine;
using Michsky.MUIP;
using ChartAndGraph;

/// <summary>
/// Updates a pie chart to display the distribution of power generated by turbines over a selected time range.
/// </summary>
[ExecuteAlways] // Ensures the script updates the Inspector in edit mode
public class PieChartPowerTurbines : MonoBehaviour
{
    /// <summary>
    /// Dropdown for selecting the time range.
    /// </summary>
    [SerializeField] private CustomDropdown timeDropdown;

    /// <summary>
    /// Container holding turbine data.
    /// </summary>
    [SerializeField] private TurbineDataContainer turbineDataContainer;

    /// <summary>
    /// Reference to the pie chart being updated.
    /// </summary>
    public ChartAndGraph.PieChart chart;

    /// <summary>
    /// Maximum number of turbines to display in the chart.
    /// </summary>
    [SerializeField] private int maxValuesToDisplay = 9;

    [Header("Materials for Turbines")]
    /// <summary>
    /// Array of materials assigned to turbines for the chart representation.
    /// </summary>
    [SerializeField] private Material[] assignedMaterials;

    [Header("Colors (Randomized)")]
    /// <summary>
    /// List of hover colors for turbines in the chart.
    /// </summary>
    public List<Color> hoverColors = new List<Color>();

    /// <summary>
    /// List of selected colors for turbines in the chart.
    /// </summary>
    public List<Color> selectedColors = new List<Color>();

    /// <summary>
    /// Current index of the dropdown selection.
    /// </summary>
    private int currentIndex;

    /// <summary>
    /// Ensures list sizes and materials are consistent with the turbine data.
    /// </summary>
    private void OnValidate()
    {
        if (turbineDataContainer != null)
        {
            AdjustListSize(hoverColors, turbineDataContainer.turbines.Length, GenerateRandomColor());
            AdjustListSize(selectedColors, turbineDataContainer.turbines.Length, GenerateRandomColor());
            AdjustMaterialsArraySize();
        }
    }

    /// <summary>
    /// Initializes the pie chart and sets up the dropdown listener.
    /// </summary>
    private void Start()
    {
        if (timeDropdown == null || turbineDataContainer == null || chart == null)
        {
            Debug.LogError("Please assign all required references in the inspector.");
            return;
        }

        currentIndex = timeDropdown.selectedItemIndex;
        timeDropdown.onValueChanged.AddListener(OnDropdownValueChanged);

        UpdateChart();
    }

    /// <summary>
    /// Updates the chart when the dropdown value changes.
    /// </summary>
    /// <param name="selectedIndex">The selected dropdown index.</param>
    private void OnDropdownValueChanged(int selectedIndex)
    {
        currentIndex = selectedIndex;
        UpdateChart();
    }

    /// <summary>
    /// Updates the pie chart data based on the current dropdown selection.
    /// </summary>
    private void UpdateChart()
    {
        chart.DataSource.Clear();

        Dictionary<string, float> turbinePowers = new Dictionary<string, float>();
        int startIndex = Mathf.Max(0, currentIndex - maxValuesToDisplay + 1);
        float totalPower = 0;

        for (int j = 0; j < turbineDataContainer.turbines.Length; j++)
        {
            float turbineTotal = 0;
            for (int i = startIndex; i <= currentIndex; i++)
            {
                turbineTotal += turbineDataContainer.turbines[j].powers[i];
            }

            string turbineName = turbineDataContainer.turbines[j].turbineID;
            turbinePowers[turbineName] = turbineTotal;
            totalPower += turbineTotal;
        }

        for (int i = 0; i < turbineDataContainer.turbines.Length; i++)
        {
            string turbineName = turbineDataContainer.turbines[i].turbineID;
            if (!turbinePowers.ContainsKey(turbineName)) continue;

            float percentage = totalPower > 0 ? (turbinePowers[turbineName] / totalPower) * 100f : 0;

            if (!chart.DataSource.HasCategory(turbineName))
            {
                Material material = assignedMaterials[i];
                Color hover = hoverColors[i];
                Color selected = selectedColors[i];
                ChartDynamicMaterial dynamicMaterial = new ChartDynamicMaterial(material, hover, selected);

                chart.DataSource.AddCategory(turbineName, dynamicMaterial, 1.0f, 1.0f, 0.0f);
            }

            chart.DataSource.SetValue(turbineName, percentage);
        }
    }

    /// <summary>
    /// Ensures the materials array matches the number of turbines in the data container.
    /// </summary>
    private void AdjustMaterialsArraySize()
    {
        if (turbineDataContainer == null) return;

        if (assignedMaterials == null || assignedMaterials.Length != turbineDataContainer.turbines.Length)
        {
            Material[] newMaterials = new Material[turbineDataContainer.turbines.Length];

            for (int i = 0; i < newMaterials.Length; i++)
            {
                newMaterials[i] = i < assignedMaterials?.Length ? assignedMaterials[i] : null;
            }

            assignedMaterials = newMaterials;
        }
    }

    /// <summary>
    /// Generates a random color.
    /// </summary>
    /// <returns>A randomly generated color.</returns>
    private Color GenerateRandomColor()
    {
        return new Color(UnityEngine.Random.value, UnityEngine.Random.value, UnityEngine.Random.value);
    }

    /// <summary>
    /// Adjusts the size of a list to match a target size, filling with a default value if necessary.
    /// </summary>
    /// <typeparam name="T">The type of the list elements.</typeparam>
    /// <param name="list">The list to adjust.</param>
    /// <param name="targetSize">The desired size of the list.</param>
    /// <param name="defaultValue">The default value to use for new elements.</param>
    private void AdjustListSize<T>(List<T> list, int targetSize, T defaultValue)
    {
        while (list.Count < targetSize)
        {
            list.Add(defaultValue);
        }
        while (list.Count > targetSize)
        {
            list.RemoveAt(list.Count - 1);
        }
    }
}
